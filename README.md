[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15567399&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.


Software Engineering is a subset in the domain of Computer Science which deals with design, 
writing, testing and maintenance of programs meant to harness functionality of computers.


Identify and describe at least three key milestones in the evolution of software engineering.


1. Introduction of (High level)programming Languages
    The first computer codes were much specialized to serve only the purpose they were built for, 
    e.g. the Turing Machine.
    This brought about creation of low-level machine code which soon or later turned tideous. 
    IBM brought about Fortran oin 1954 which motivated development of COBOL by McCarthy Jon (1954). 
    The unsung hero, Dennis Ritchie, alongside Ken Thompson designed the syntax of Ansi C. 
    Later on was abstracted to several other abstract programming languages.

2. SE as a discipline
    Early 1960s, SE was recognized as a subset in the domain of Engineering.
    As you can imagine, the early years were the toughest. Expensive inefficient equipment, 
    expert-level syntax for beginners (only mathematicians survived the feat I suppose!). 
    This was well-nartured and today, a highly performing field.

3. Automation era
    The earliest application of software for automation in the mechanical industry dates back to 
    the 1950s and 1960s. One of the pioneering developments during this period was the use of 
    Numerical Control (NC) machines, which were programmed using punched tapes to automate the 
    control of machine tools. This technology marked a significant milestone in manufacturing, 
    as it allowed for precise and repeatable control of machining operations, reducing the need 
    for manual intervention and improving productivity.

    The significance of this early automation in the mechanical industry cannot be overstated in 
    the context of software engineering. It laid the groundwork for the development of more 
    sophisticated computer-aided manufacturing (CAM) systems and the broader integration of software 
    in industrial processes. This early intersection of software and mechanical engineering also 
    drove the need for more robust and reliable software, pushing the boundaries of what software 
    could achieve. As a result, it contributed to the evolution of software engineering as a 
    discipline, highlighting the importance of software in controlling complex systems and leading to 
    advancements in programming languages, software design, and testing methodologies tailored for automation.

4. AI era
    The evolution of Artificial Intelligence (AI) as a breakthrough in software engineering began in 
    the 1950s, laying the foundation for machines that could mimic human intelligence. Alan Turing, 
    one of the earliest pioneers, introduced the idea of machine intelligence in his 1950 paper 
    "Computing Machinery and Intelligence," where he proposed the Turing Test to evaluate a machine's 
    ability to exhibit intelligent behavior. The Dartmouth Conference in 1956, organized by John McCarthy, 
    Marvin Minsky, Nathaniel Rochester, and Claude Shannon, marked the formal beginning of AI as a field. 
    This conference led to the coining of the term "Artificial Intelligence" and spurred research into 
    early AI programs, such as the Logic Theorist and the General Problem Solver, which laid the groundwork 
    for symbolic AI.

    The significance of AI as a breakthrough in software engineering became more pronounced in the 1980s 
    and 1990s, with the rise of machine learning and neural networks. Researchers like Geoffrey Hinton, 
    Yann LeCun, and Yoshua Bengio pioneered deep learning techniques, which dramatically improved the 
    ability of machines to learn from data and recognize patterns. This period saw the development of 
    algorithms and frameworks that enabled the practical application of AI in areas such as image recognition, 
    natural language processing, and autonomous systems. The 21st century has seen AI integrated into various 
    software engineering processes, from automated testing to intelligent coding assistants, revolutionizing 
    the field and opening new avenues for innovation.



List and briefly explain the phases of the Software Development Life Cycle.

1. Design
    This, being the initial stage, a software is planned to solve a problem under a particular domain.
    Early development of list of requirements is usually done here.
2. Development
    Software crafters(Engineers) get hands-dirty to build a well-structured application, tailored to solve 
    the problem identified.
3. Deployment
    This stage is about releasing a software product to the end user. It usually comes around with regular 
    maintenance cycles i.e. continuous Integration / continuous deployment.
4. Maintenance
    You might wonder if a software wears(well it does). dependancies may become outdated, some components 
    may change due to changing needs, feedback from customers needs to be satisfied... all this calls for 
    immediate action of rewriting some components.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

Waterfall is a linear system of working that requires a team to complete each project phase before moving 
to the next one, while Agile, encourages a team to work simultaneously on dirrerent phases of the project.

For a one-time contract, Waterfallwould be the most appropriate, as the client needs only one version of 
a complete product. On the other hand, agile method would be used for a dynamic product, where both budget, 
requirements and time are not fixed.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

1. Software Developer
    One who writes new code for a product and modifies existing codebase where necessary.

2. QA Engineer
    An advanced software engineer who writes tests and checks various metrics in a software product.

3. Project Manager
    One who ensures seamless performance across all departments under a project. They oversee development 
    procedures and conduct board meetings


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

These softwares provide a friendly text(isn't code text?) editing environment for software engineers.
This includes but not limined to:
    1. Vim editor
    2. Micro editor
    3. Kwrite
    4. IntelliJ
    5. Eclipse
    6. Microsoft's VSCode & MSVC editors
Version Control on the other side, tracks changes and enables for team work in software development.
They include but not limited to:
    1. Gitlab
    2. Github


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

1. Time Constraints
    Meeting deadlines can sometimes be a nightmare when one can't fix a bug in time.
2. Toxic Company Culture
    Some companies make it hard for Engineers to cope with the system.
3. Burnouts
    Once in a while, some engineers have to strain, overworking with no overtime compensation
    so as to meet requirements.
4. Health matters
    What would you expect for a chad who stares at their screens for close to 10 hours a day?
    Health-related issues may arise, mostly obasity and blindness(myopia, hypermetropia).
5. Exposure time with family (some of the engineers)
    Some barely find time to hang around with family due to intense workloads.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

1. Unit
    This involves testing a single component of the whole architecture
2. Integration
    This involves adding new functional instruction sets to the system.
3. System
    This is the whole functional arcitecture, well-tested and running in good condition
4. Acceptance
    This is an indicator for units passing tests which shall then be integrated to the system.


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Definition
    Prompt Engineering is the act of feedin AI with specialized data, so as to get a more desired
    output from it.

Importance
1. Gaining control over AI output.
2. Used when fine-tuning AI for better user experience.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Vague:
    "You are tasked with writing a kernel from ground-up, provide a directory structure and write the whole kernel"
Improved:
Break it down into parts:
    1. "develop a directory structure for a potentially amazing kernel"
    2. "develop a bootloader and provide well-commented code" (this is assembly you know)
    3. "enable the A20 gate"; ...

Obviously, a kernel is a huge modular project. This second approach is more convenient since you have 
the project in your control rather than letting AI deduce implicitly what to add and what to exclude.
